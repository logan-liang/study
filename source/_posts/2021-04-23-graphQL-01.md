---
title: GraphQL查询和变更
tags:
  - GraphQL
categories:
  - GraphQL 入门
comments: true
date: 2021-04-23 11:30:28
---


## GraphQL 介绍

GraphQL 是一个用于API的查询语言，是一个适用基于类型系统来执行查询的服务端运行时。GraphQL并没有和任何特定数据库或者存储引擎绑定，而是依靠你现有的代码和数据支撑。

一个GraphQL服务是通过定义类型和类型上的字段来创建的，然后每个类型上的每个字段提供解析函数。

一旦一个GraphQL服务运行起来，它就能接收GraphQL查询，并验证和执行。接收到的查询首先会被检查确保它只引用了已定义的类型和字段，然后运行指定的解析函数来生产结果。

## 查询和变更

### 字段（Fields）

简单而言，GraphQL是关于请求对象上的特定字段。我们以一个非常简单的查询以及其结果为例：

```
{
  hero{
    name
    id
  }
}
```
输出

```
{
  "data":{
    "hero":{
      "name":"R2-D2",
      "id":"2001"
    }
  }
}
```
你立即就能发现，查询和其结果拥有几乎一样的结构。这是GraphQL最重要的特性，因为这样一来，你就总是能得到你想要的数据，而服务器也准备的知道客户端请求的字段。

你也可以适用对象类型，你可以对这个对象的字段进行次级选择（sub-selection）。GraphQL查询能够遍历相关对象及其字段，使得客户端可以一次请求查询大量相关数据，而不像传统REST架构中那样需要多次往返查询。如下例子：

```
{
  hero {
    name
    # 查询可以有备注！
    friends {
      name
    }
  }
}
```
输出

```
{
  "data": {
    "hero": {
      "name": "R2-D2",
      "friends": [
        {
          "name": "Luke Skywalker"
        },
        {
          "name": "Han Solo"
        },
        {
          "name": "Leia Organa"
        }
      ]
    }
  }
}
```
注意这个例子中，friends 返回了一个数组的项目，GraphQL 查询会同等看待单个项目或者一个列表的项目，然而我们可以通过 schema 所指示的内容来预测将会得到哪一种。

### 参数（Arguments）

即使我们能做的仅仅是遍历对象及其字段，GraphQL就已经是一个非常有用的数据查询语言了。但是当你加入给字段传递参数的能力时，事情会变得更加有趣。

```
{
  human(id: "1000") {
    name
    height
  }
}
```

输出

```
{
  "data": {
    "human": {
      "name": "Luke Skywalker",
      "height": 1.72
    }
  }
}
```
在类似REST的系统中，你只能传递一组简单参数--请求中的query参数和URL段。但是在GraphQL中，每一个字段和潜逃对象都能有自己的一组参数，从而使得GraphQL可以完美替代多次API请求获取。甚至你也可以给标量（scalar）字段传递参数，用于实现服务端的一次转换，而不用每个客户端分别转换。

```
{
  human(id: "1000") {
    name
    height(unit: FOOT)
  }
}
```

输出

```
{
  "data": {
    "human": {
      "name": "Luke Skywalker",
      "height": 5.6430448
    }
  }
}
```

参数可以是多种不同的类型。上面例子中，我们使用了一个枚举类型，其代表了一个有限选项集合。GraphQL自带一套默认类型，但是GraphQL服务器可以声明一套自己的定制类型，只要能序列化成你的传输格式即可。


### 别名（Aliases）

如果你眼睛够锐利，你可能已经发现，即便结果中的字段与查询中的字段能够匹配，但是因为他们并不包含参数，你就没法通过不同参数来查询相同字段。这便是为何需要别名--这可以让你重命名结果中的字段为任意你想到的名字。

```
{
  empireHero: hero(episode: EMPIRE) {
    name
  }
  jediHero: hero(episode: JEDI) {
    name
  }
}
```

输出

```
{
  "data": {
    "empireHero": {
      "name": "Luke Skywalker"
    },
    "jediHero": {
      "name": "R2-D2"
    }
  }
}
```

上例中，两个hero字段将会存在冲突，但是因为我们可以将其另取一个别名，我们也就可以在一次请求中得到两个结果。

### 片段（Fragments）

假设我们的app有比较复杂的页面，将正反派主角及其友军分为两拨。你立马就能想到对应的查询会变得复杂。

这就是为何GraphQL包含了称作片段的可复用单元。片段使你能够组织一组字段，然后再需要它们的地方引入。如下：

```
{
  leftComparison: hero(episode: EMPIRE) {
    ...comparisonFields
  }
  rightComparison: hero(episode: JEDI) {
    ...comparisonFields
  }
}

fragment comparisonFields on Character {
  name
  appearsIn
  friends {
    name
  }
}
```

输出

```
{
  "data": {
    "leftComparison": {
      "name": "Luke Skywalker",
      "appearsIn": [
        "NEWHOPE",
        "EMPIRE",
        "JEDI"
      ],
      "friends": [
        {
          "name": "Han Solo"
        },
        {
          "name": "Leia Organa"
        },
        {
          "name": "C-3PO"
        },
        {
          "name": "R2-D2"
        }
      ]
    },
    "rightComparison": {
      "name": "R2-D2",
      "appearsIn": [
        "NEWHOPE",
        "EMPIRE",
        "JEDI"
      ],
      "friends": [
        {
          "name": "Luke Skywalker"
        },
        {
          "name": "Han Solo"
        },
        {
          "name": "Leia Organa"
        }
      ]
    }
  }
}
```
你可以看到上面的查询如何漂亮地重复了字段。片段的概念经常用于将复杂的应用数据需求分割成小块，特别是你要将大量不同片段的UI组件组合成一个初始数据获取的时候。

#### 在片段内使用变量

片段可以访问查询或变更中声明的变量。

```
query HeroComparison($first: Int = 3) {
  leftComparison: hero(episode: EMPIRE) {
    ...comparisonFields
  }
  rightComparison: hero(episode: JEDI) {
    ...comparisonFields
  }
}

fragment comparisonFields on Character {
  name
  friendsConnection(first: $first) {
    totalCount
    edges {
      node {
        name
      }
    }
  }
}
```

### 操作名称（Operation name）

在这之前，我们都使用了简写句法，省略了query关键字和查询名称，但是生产中使用这些可以使我们代码减少歧义。

下面的示例包含了作为操作类型的关键字 query 以及操作名称：

```
query HeroNameAndFriends {
  hero {
    name
    friends {
      name
    }
  }
}
```

`操作类型`可以是query、mutaion和subscription，描述你打算做什么类型的操作。
`操作名称`是你的操作的有意义和明确的名称。

### 变量（Variables）

目前为止，我们将擦书卸载了查询字段内。但是在很多应用中，字段的参数可能是动态的。
使用之前，我们得做三件事：

* 使用`$variableName` 替代查询中的静态值。
* 声明`$variableName` 为查询接收的变量之一。
* 将`$variableName ：value`通过传输专用（通常是json）的分离的变量字典中。

全部做完会像这个样子：

```
# { "graphiql": true, "variables": { "episode": JEDI } }
query HeroNameAndFriends($episode: Episode) {
  hero(episode: $episode) {
    name
    friends {
      name
    }
  }
}
```

#### 变量定义（Variable definitions）

变量定义看上去像是上述查询中的 `($episode: Episode)`。其工作方式跟类型语言中函数的参数定义一样。它以列出所有变量，变量前缀必须为 `$`，后跟其类型，本例中为 `Episode`。

#### 默认变量（Default variables）

可以通过在查询中的类型定义后面附带默认值的方式，将默认值付给变量。

```
query HeroNameAndFriends($episode: Episode = "JEDI") {
  hero(episode: $episode) {
    name
    friends {
      name
    }
  }
}
```

## 指令（Directives）

一个指令可以附着在字段或者片段包含的字段上，然后以任何服务端期待的方式来改变查询的执行。GraphQL 的核心规范包含两个指令，其必须被任何规范兼容的 GraphQL 服务器实现所支持：

* `@include(if: Boolean)` 仅在参数为 true 时，包含此字段。
* `@skip(if: Boolean)` 如果参数为 true，跳过此字段。

指令在你不得不通过字符串操作来增减查询的字段时解救你。服务端实现也可以定义新的指令来添加新的特性。例子：

```
query Hero($episode: Episode, $withFriends: Boolean!) {
  hero(episode: $episode) {
    name
    friends @include(if: $withFriends) {
      name
    }
  }
}
```

## 变更 （Mutations）

建一个约定来规范任何导致写入的操作都应该显式通过变更（mutation）来发送。就如同查询一样，如果任何变更字段返回一个对象类型，你也能请求其嵌套字段。获取一个对象变更后的新状态也是十分有用的。我们来看看一个变更例子：

```
mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) {
  createReview(episode: $ep, review: $review) {
    stars
    commentary
  }
}
```
参数：

```
{
  "ep": "JEDI",
  "review": {
    "stars": 5,
    "commentary": "This is a great movie!"
  }
}
```

返回：

```
{
  "data": {
    "createReview": {
      "stars": 5,
      "commentary": "This is a great movie!"
    }
  }
}
```
#### 变更多个字段（Multiple fields in mutations）

一个变更也能包含多个字段，一组查询。查询和变更之间名称之外的一个重要区别是：

`查询字段时，是并行执行，而变更字段时，是线性执行，一个接着一个。`

这意味着如果我们一个请求中发送了两个 incrementCredits 变更，第一个保证在第二个之前执行，以确保我们不会出现竞态。

## 内联片段（Inline Fragments）

如果你查询的字段返回的是接口或者联合类型，那么你可能需要使用内联片段来取出下层具体类型的数据：

```
query HeroForEpisode($ep: Episode!) {
  hero(episode: $ep) {
    name
    ... on Droid {
      primaryFunction
    }
    ... on Human {
      height
    }
  }
}

参数
{
  "ep": "JEDI"
}
```

返回

```
{
  "data": {
    "hero": {
      "name": "R2-D2",
      "primaryFunction": "Astromech"
    }
  }
}
```

#### 元字段（Meta fields）

某些情况下，你并不知道你将从 GraphQL 服务获得什么类型，这时候你就需要一些方法在客户端来决定如何处理这些数据。GraphQL 允许你在查询的任何位置请求 `__typename`，一个元字段，以获得那个位置的对象类型名称。

```
{
  search(text: "an") {
    __typename
    ... on Human {
      name
    }
    ... on Droid {
      name
    }
    ... on Starship {
      name
    }
  }
}
```

输出
```
{
  "data": {
    "search": [
      {
        "__typename": "Human",
        "name": "Han Solo"
      },
      {
        "__typename": "Human",
        "name": "Leia Organa"
      },
      {
        "__typename": "Starship",
        "name": "TIE Advanced x1"
      }
    ]
  }
}
```

