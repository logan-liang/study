---
title: 闭包
tags:
  - 函数
categories:
  - Golang
comments: true
date: 2021-03-24 14:32:15
---


当我们不希望给函数起名字的时候，可以使用匿名函数，例如：`func(x, y int) int { return x + y }`。

这样的一个函数不能够独立存在，但可以被赋值某个变量，即保存函数的地址到变量中。

```
fplus := func(x, y int) int { return x + y }

```
然后通过变量名对函数进行调用：`fplus(3,4)`

匿名函数像所有函数一样可以接受或不接受参数。下面的例子展示了如何传递参数到匿名函数中：

```
func (u string) {
	fmt.Println(u)
	…
}(v)
```

思考：下列方法输出的内容是什么？

```
package main

import "fmt"

func f() (ret int) {
	defer func() {
		ret++
	}()
	return 1
}
func main() {
	fmt.Println(f())
}
```

变量`ret`的值为2，因为`ret++`是在执行`return 1`语句后发生的。

这可用于在返回语句之后修改返回的`error`时使用。

### defer语句和匿名函数

关键字 defer 经常配合匿名函数使用，它可以用于改变函数的命名返回值。

匿名函数还可以配合`go`关键字来作为goroutine使用。

匿名函数同样称之为闭包。


### 应用闭包：将函数作为返回值

语法：

```
func Add2() (func(b int) int)
func Adder(a int) (func(b int) int)
```

函数add2不接受任何参数，但函数Adder接受一个int类型的整数作为参数。


例子：

```
func main() {
	// make an Add2 function, give it a name p2, and call it:
	p2 := Add2()
	fmt.Printf("Call Add2 for 3 gives: %v\n", p2(3))
	// make a special Adder function, a gets value 2:
	TwoAdder := Adder(2)
	fmt.Printf("The result is: %v\n", TwoAdder(3))
}

func Add2() func(b int) int {
	return func(b int) int {
		return b + 2
	}
}

func Adder(a int) func(b int) int {
	return func(b int) int {
		return a + b
	}
}
```

输出：

```
Call Add2 for 3 gives: 5
The result is: 5
```


