---
title: Redis-分布式锁
tags:
  - Redis-分布式锁
categories:
  - Redis
comments: true
date: 2022-07-05 16:33:43
---


### 基于SETNX、EXPIRE实现锁
#### 语法
set key value nx ex timeOut

NX：只有这个key不存在的时候才会进行操作，即 if not exists
EX：设置key的过期时间为秒，具体时间由第五个参数决定
timeOut：设置过期时间保证不会出现死锁

#### 原理
总的来说，执行上面的set 会导致两种结果：
1、当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。
2、已有锁存在，不做任何操作。

### 基于 redisson实现分布式锁
#### 什么是redisson？
是一个redis的基础上实现的java常驻内存数据网络。就是在redis的基础上封装了很多功能，以便于我们更方便的使用。

#### 加锁流程

客户端N->获取锁->加锁成功（如失败继续获取锁）->看门狗->redis分布式节点存储

#### 语法

lock=redisson.getLock("myLock")；
lock.lock();//加锁
lock.unlock(); //解锁

#### 互斥锁
假如客户A已经拿到了myLock，现在有客户B想进入：
* 判断是否存在锁
* 判断客户端A重新请求，证明当前是同一个客户端同一个线程重新进入，标志+1，重新刷新生存时间（可重入），否则进入下一个if。
* 客户端B会获取到pttl mylock返回的一个数字，这个数字代表mylock这个锁key的剩余生存时间。此时客户端B会进入一个while循环，不停的尝试加锁。

#### watch dog 看门狗

可以自定义设置看门狗的监控超时时间。
如果还没执行完毕，监听到这个客户端A的线程还持有锁，就去续期，默认是10秒监听一次，如果还持有，就不断的延长锁的有效期。

### 分布式锁的缺点

如果是主从、哨兵模式，当客户端A把myLock 这个锁的key的value写入了master，此时会异步复制给slave实例。
万一在这个主从复制的过程中master宕机了，主备切换，slave变成了master。
那么这个时候slave还没来得及加锁，此时客户端A的myLock的值是没有的，客户端B在请求时，myLock却成功为自己加了锁。这时候分布式锁就失效了，就会导致数据有问题。
所以说redis分布式锁最大的缺点就是宕机导致多个客户端加锁，导致脏数据，这种几率还是很小的。

### 防坑指南
* setnx 需要同时设置 nx ex ，不然会导致 非同步，加锁混乱的情况
* setnx的值 必须作为唯一凭证，最后销毁锁的时候校验当前锁是否是要销毁的