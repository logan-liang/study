---
title: 变量
tags:
  - 基本结构和基本数据类型
categories:
  - Golang
comments: true
date: 2021-03-07 19:23:07
---


### 简介

声明变量的一般形式是使用`var`关键字：`var identifier type`。

需要注意的是，Go和许多编程语言不同，它在声明变量时将变量的类型放在变量的名称之后。Go为什么要选择这么做呢？

首先，它是为了避免像C语言中那样含糊不清的声明形式，例如：`int * a,b`。而在Go语言中，则可以很轻松地将它们都声明为指针类型：

`
    var a,b *int
`
其次，这种语法能够按照从左至右的顺序阅读，使得代码更加容易理解。

示例：

```
    var a int
    var b boll
    var str string
```

你也可以改写成这种形式：

```
    var(
        a int
        b bool
        c string
    )
```

这种因式分解关键字的写法一般用于声明全局变量。

当一个变量被声明之后，系统自动赋予它该类型的零值：int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil。记住，所有的内存在 Go 中都是经过初始化的。

变量的命名规则遵循骆驼命名法，即首个单词小写，每个新单词的首字母大写，例如：`numShips` 和 `startDate`。

但如果你的全局变量希望能够被外部包所使用，则需要将首个单词的首字母也大写。

一个变量（常量、类型和函数）在程序中都有一定的作用范围，称之为作用域。如果一个变量在函数体外声明，则被认为是全局变量，可以在整个包甚至外部包（被导出后）使用，不管你声明在哪个源文件里或在哪个源文件里调用该变量。

在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量。

### 值类型和引用类型

程序中所用到的内存在计算机中使用一堆箱子来表示，这些箱子被称为“字”。根据不同的处理器以及操作系统类型，所有的字都具有32位（4字节）和64位（8字节）的相同长度；所有的字都使用相关的内存地址来进行表示。

所有像int、float、bool和string这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值。

另外，像数组和结构这些复合类型也是值类型。

当使用等号`=`将一个变量的值赋值给另一个变量时，如：`j=i`，实际上是在内存中将i的值进行了拷贝。

你可以通过`&i`来获取i的内存地址，例如：0xf840000040（每次的地址都可能不一样）。值类型的变量的值存储在栈中。

内存地址会根据机器的不同而有所不同，甚至相同的程序在不同的机器上执行后也会有不同的内存地址。因为每台机器可能有不同的存储器布局，并且位置分配也不同。

更复杂的数据通常会需要使用多个字，这些数据一般使用引用类型保存。

一个引用类型的变量r1存储的是r1的值所在的内存地址，或内存地址中第一个字所在的位置。

这个内存地址被称之为指针，这个指针实际上也被存在另外的某一个字中。

同一个引用类型的指针指向的多个字可以是在连续的内存地址中，这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，每个字都指示了下一个子所在的内存地址。

当使用赋值语句`r2=r1`时，只有引用（地址）被复制。

如果r1的值被改变了，那么这个值的所有饮用都会指向被修改后的内容，在这个例子中r2也会受到影响。

在Go语言中，指针属于引用类型，其它的引用类型还包括slices，maps和channel。被引用的变量会存在堆中，以便进行垃圾回收，且比栈拥有更大的内存空间。

### 简短形式，使用:=赋值操作符

我们知道可以在变量的初始化时省略变量的类型而由系统自动推断。

这是使用变量的首选形式，但是它只能被用在函数体内，而不可以用于全局变量的声明与赋值。使用操作符`:=`可以高效地创建一个新的变量，称之为初始化声明。

多变量可以在同一行进行赋值，如：

```
    a,b,c:=5,7,"abc"
```

右边的这些值以相同的顺序赋值给左边的变量，所以a的值是`5`，b的值是`7`，c的值是`"abc"`。

这些成为`并行`或`同时`赋值。

空白标识符`_`也被用于抛弃值，如值`5`在：`_,b=5,7`中被抛弃。

### init 函数

变量除了可以在全局声明中初始化，也可以在init函数中初始化。这是一类非常特殊的函数，它不能够被人为调用，而是在每个包完成初始化后自动执行，并且执行优先级比main函数高。

每个源文件都只能包含一个init函数。初始化总是以单线程执行，并且按照包的依赖关系顺序执行。

一个可能的用途是在开始执行程序之前对数据进行检验或修复，以保证程序状态的正确性。




