---
title: MySQL-锁
tags:
  - MySQL锁
categories:
  - MySQL
comments: true
date: 2022-07-05 09:40:03
---



### 种类

#### 乐观锁

用数据版本记录机制实现，这是乐观锁最常用的一种实现方式。

#### 悲观锁

指的是在操作数据时，认为此操作会出现冲突，所以在进行每次操作时都要通过获取锁才能进行对相同数据的操作。
##### 共享锁（读锁，lock in share mode）
是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改，直到已释放所有共享锁。当事务对读锁进行修改操作，很可能会造成死锁。
##### 排他锁（写锁 for update）
若某个事务对某一行加上了排他锁，只能对这个事务进行读写，在此事务结束之前，其他事务不能对其进行加任何锁，其他进程可以读取，但不能写操作，需等待其释放。

### 锁级别

#### 表级锁

开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突的概率最高，并发度低。
表锁使用的是一次性锁技术，在会话开始的地方使用lock命令将后续需要用到的表都加上锁，在表释放前，只能访问这些加锁的表，不能访问其他表，直到最后通过 unlock tables 释放锁。
除了unlock tables显示释放锁之外，会话持有其他表锁时执行lock table语句会释放会话之前持有的锁；会话持有其他表锁时执行 start transaction 或者begin开启事务时，也会释放之前持有的锁。

#### 行级锁

开销大，加锁慢；会出现死锁；锁定力度最小，发生锁冲突的概率最低，并发度也最高。


### InnoDB锁特性

* 在不通过索引条件查询的时候，InnoDB使用的是表锁。
* 由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。
* 当表有多个索引的时候，不同的事务可以是同不同的索引锁定不同的行，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。
* 即便在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，这种情况下将使用表锁，而不是行锁。因此，在分析锁冲突时，别忘了检查SQL的执行计划explain。