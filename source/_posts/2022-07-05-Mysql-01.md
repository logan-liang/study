---
title: MySQL-索引原理
tags:
  - MySQL索引
categories:
  - MySQL
comments: true
date: 2022-07-05 09:40:03
---


### 索引目的

提高查询效率。

### 索引原理

数据库实现比较复杂，数据保存在磁盘上，而为了提高性能，每次又可以把部分数据读入内存计算，因为我们直到访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。

#### 磁盘IO与预读

磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分。
* 寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下；
* 旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2=4.17ms;
* 传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。

那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17=9ms左右，如果执行一次IO的时间可以执行40万条指令，数据库动辄十万百万乃至千万级数据，每次9毫秒时间，显然是个灾难。

考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问。每一次IO读取的数据我们称之为一页。具体一页有多大数据跟操作系统有关，一般为4K或8K，也就是我们读取一页内的数据时候，实际上才发生了一次IO。

#### 索引数据结构-B+树

每个磁盘块包含几个数据项和指针，如磁盘块1包含数据项17和35，包含指针p1、p2、p3，P1表示小于17的磁盘块，p2表示在17和35之间的磁盘块，p3表示大于35的磁盘块。真实的数据存在于叶子节点，非叶子节点只存储指引搜索方向的数据项。

#### B+树的查找过程

如以上例子所示，如果要查找数据项，首先会把磁盘块A由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定数据位置，锁定磁盘块A的指针，反复操作，直到找到数据为止。
三层的B+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的。没有索引每个数据项发生一次IO，成本非常高。

#### B+树性质

* 通过上面的分析，我们知道IO次数取决于B+树的高度，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。

* 当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。

#### 慢查询优化

##### 建立索引的原则

* 最左前缀匹配原则，非常重要的原则，mysql会一直项右匹配直到遇到范围查询(>、<、between、like)就停止匹配。
* =和in可以乱序，mysql的查询优化器会帮我们优化成可以识别的形式。
* 尽量选择区分度高的列作为索引，区分度的公式:count(distinct col)/count(*)。表示字段不重复的比例，比例越大我们扫描的记录数越小。
* 索引列不能参与计算，保持列“干净”。
* 尽量的扩展索引，不要新建索引。意思就是建立复合索引。

##### 查询优化神器-explain命令

这里需要强调的是rows是核心指标，绝大部分rows小的语句一定很快。所以优化语句基本上都是在优化rows。

##### 慢查询优化基本步骤

* 先运行看看是否真的很慢，注意设置SQL_NO_CACHE
* where条件单表查，锁定最小返回记录表。
* explain查看执行计划，是否与预期一致。
* order by limit 形式的sql语句让排序的表优先查
* 了解业务使用场景
* 加索引时参照建索引的几大原则
* 观察结果，不符合预期继续从0分析






