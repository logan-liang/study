---
title: 数组与切片 
tags:
  - 数组与切片
categories:
  - Golang
comments: true
date: 2021-03-24 15:54:30
---


## 数组声明与初始化

数组时具有相同`唯一类型`的一组已编号且长度固定的数据项序列。

数组元素可以通过`索引`（位置）来读取或修改，索引从0开始，第一个元素索引为0，第二个索引为1，以此类推。数组长度最大为2GB。

声明格式为：

```
    var arr1 [5]int
```
Go语言中的数组是一种`值类型`，可以通过`new()`来创建。那么使用这种方式和正常声明有什么区别呢？

这样的结果就是当把一个数组赋值给另一个时，需要再做一次数组内存的拷贝操作。

## 数组常量

如果数组值已经提前知道了，那么可以通过`数组常量`的方法来初始化数组，而不用一次使用`[]=`方法。

第一种变化：

```
    var arr=[5]int{1,2,3,4,5}
```
注意 `[5]int` 可以从左边起开始忽略：`[10]int {1, 2, 3}` :这是一个有 10 个元素的数组，除了前三个元素外其他元素都为 `0`。

第二种变化：

```
    var arrLazy = [...]int{5, 6, 7, 8, 22}
```

`...` 可同样可以忽略，从技术上说它们其实变化成了切片。


第三种变化：

```
    var arrKeyValue = [5]string{3: "Chris", 4: "Ron"}
```

只有索引 3 和 4 被赋予实际的值，其他元素都被设置为空的字符串

## 将数组传递给函数

把一个大数组传递给函数会消耗很多内存。有两种方法可以避免这种现象：

* 传递数组的指针
* 使用数组的切片


## 切片

切片（slice）是对数组一个连续片段的引用，所以切片是一个引用类型。这个片段可以是整个数组，或者时由起始和终止索引标识的一些项的子集。

切片是可以索引的，并且可以由`len()`函数获取长度。

切片时一个长度可变的数组。

切片提供了计算容量的函数`cap()`，可以测量切片最长可以达到多少。

多个切片如果表示同一个数组的片段，它们可以共享数据；因此一个切片和相关数组的其它切片都是共享存储的，相反，不同的数组总是导标不同的存储。

`优点`因切片时引用，所以它们不需要使用额外的内存并且比使用数组更有效率，所以在go代码中切片比数组更常用。

### 创建切片

```
slice:=make([]int,len,cap)
slice:=new([]int)
```

### new()和make()的区别

* new(T) 为每个新的类型T分配一片内存，初始化为0并且返回类型为*T的内存地址，她适用于值类型数组和结构体，相当于`&T{}`

* make(T) 返回一个类型为T的初始值，他只适用于3种内建的引用类型：切片、map和channel。


### 切片重组

改变切片长度的过程称之为切片重组 reslicing

示例：

```
    slice1 = slice1[0:end]
```

### 切片的复制与追加

* 追加 append(s[]T,x ...T):将0个或多个具有相同类型s的元素追加到切片后面并且返回新的切片；追加的元素必须和原切片的元素同类型。如果s的容量不足以存储新增元素，append会分配新的切片来保证已有切片元素和新增元素的存储。因此，返回的切片可能已经指向一个不同的相关数组了。append方法总是返回成功，除非系统内存耗尽。

* 复制 copy(dst,src []T) int: copy方法将类型为T的切片从原地址src拷贝到目标地址dst，覆盖dst的相关元素，并且返回拷贝的元素个数。原地址和目标地址可能会有重叠。拷贝个数时src和dst的长度最小值。如果src时字符串那么元素类型就是byte。如果你还想继续使用src，在拷贝结束后执行`src=dst`。


### map切片

```
func main() {
	// Version A:
	items := make([]map[int]int, 5)
	for i:= range items {
		items[i] = make(map[int]int, 1)
		items[i][1] = 2
	}
	fmt.Printf("Version A: Value of items: %v\n", items)
}
```

