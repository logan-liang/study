---
title: Go-CSP模型
tags:
  - CSP
categories:
  - Golang
comments: true
date: 2022-07-05 17:04:30
---


### CSP并发模型

是上个世纪七十年代提出的，用于描述两个独立的并发实体通过共享的通讯channel进行通讯的并发模型，通过共享内存实现并发控制。

### golang CSP

名言：不要通过共享内存来通信，而是要通过通信来共享内存。

借用CSP模型的一些概念为之实现并发进行理论支持，其实从实际上触发，仅仅借用了process和channel这两个概念。
process在go语言上的表现就是goroutine是实际并发执行的实体，每个实体之间是通过channel通讯来实现数据共享。

### Channel

用于goroutine之间的同步、通信。channel在goroutine间架起了一条管道，在管道里传输数据，实现goroutine间的通信；由于它是线程安全的，所以用起来非常方便；channel还提供“先进先出”的特性；它还能影响goroutine的阻塞和唤醒。

#### channel分为带缓冲、不带缓冲。

* 带缓冲：发送方和接收方要同步就绪，只有两者都ready的情况下，数据才能在两者间传输。否则会被阻塞。
* 不带缓冲：缓冲槽要有剩余容量，操作才会成功，否则会被阻塞。

### Goroutine
是实际并发执行的实体，他底层是使用协程（coroutine）实现并发，coroutine是一种运行在用户态的用户线程。内存占用为2KB。线程初始为1MB。

#### 特点：
* 用户空间 避免了内核态和用户态的切换导致的成本
* 可以由语言和框架层进行调度
* 更小的栈空间允许创建大量的实例

### Goroutine调度器

* M：Machine, 代表着一个内核线程，也可以称为系统线程，goroutine跑在M之上的。
* P：Processor，处理器，它的主要用途就是用来执行goroutine的，它维护了一组goroutine队列。
* G：goroutine，是go语言调度器中待执行的任务，是对Go中代码片段的封装，其实是一种轻量级的用户态线程。
* seched：调度器，他维护由存储空闲的M队列和空闲的P队列，可运行的G队列，自由的G队列以及调度器的一些状态信息等。

#### 关系：

在Go中，线程（M）是运行goroutine的实体，调度器（P）的功能是把可运行的goroutine分配到工作线程上。
* 全局队列：存放等待运行的G。
* P的本地队列：同全局队列类似，存放的也是等待运行的G，存的数量优先，不超过256个。新建G时，G优先加入到P的本地队列，如果本地队列满了，则会把本地队列中一半的G移动到全局队列。
* P列表：所有的P都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS个。
* M：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列拿一批G放到P的本地队列，或从其他P的本地队列拿一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。

#### 调度过程：

当一个G被创建的时候，它首先被压入P本地队列，如果P本地满了的情况下，会把本地队列一半的G压入全局队列，所有的P都在程序启动时创建，由默认的GOMAXPROCS个控制，默认是cpu个数。线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列拿一批G放到P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。