---
title: RabbitMQ-防数据丢失
tags:
  - RabbitMQ-数据丢失
categories:
  - RabbitMQ
comments: true
date: 2022-07-06 17:54:21
---



### 数据丢失场景

一条消息整个过程要经历两次的网络传输：从生产者发送到RabbitMQ服务器，从RabbitMQ服务器发送到消费者。

* 存储在队列中，如果没有队列没有对消息持久化，RabbitMQ服务器宕机重启会丢失数据。
* 生产者发送消息到RabbitMQ服务器过程中，RabbitMQ服务器如果宕机停止服务，消息会丢失。
* 消费者从RabbitMQ服务器获取队列中存储的数据消费，但是消费者程序出错或者宕机而没有正确消费，导致数据丢失。

### 解决方式

#### 消息持久化

需要设置Exchange和Queue为持久化。具体设置查看工具包。

#### 消息确认机制-confim

生产者设置channel为confirm模式。

一旦信道进入confirm模式，所有在该信道上面发布的消息都会被指派一个唯一的ID（从1开始），一旦消息被投递到所有匹配的队列之后，broker就会发送一个确认给生产者（包含消息的唯一ID），这就使得生产者直到消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会将消息写入磁盘之后发出，broker回传给生产者的确认消息中deliver-tag域包含了确认消息的序列号，此外broker也可以设置basic.ack的multiple域，表示到这个序列号之前的所有消息都已经得到了处理。

confirm模式最大的好处在于它是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条信息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果MQ因为自身内部错误导致消息丢失，就会发送一条nack消息，生产者应用程序同样可以在回调方法中处理该nack消息。

##### 编程模式

* 普通模式：每发送一条消息后，调用waitForConfirms()方法，等待服务器端confirm。实际上是一种串行confirm。
* 批量confirm模式：每发送一批消息后，调用waitForConfirms()方法，等待服务器端confirm。
* 异步confirm模式：提供一个回调方法，服务端confirm了一条或者多条消息后Client端会回调这个方法。

##### 基于异步confirm模式的实现思路

主要解决问题：在生产者发送到rabbit server时，因网络问题导致投递失败，从而数据丢失。

```
func publish(){
........
log.Printf("enabling publishing confirms.")
if err := channel.Confirm(false); err != nil {
	return fmt.Errorf("Channel could not be put into confirm mode: %s", err)
}
confirms := channel.NotifyPublish(make(chan amqp.Confirmation, 1))

defer confirmOne(confirms)
.......
}

func confirmOne(confirms <-chan amqp.Confirmation) {
	log.Printf("waiting for confirmation of one publishing")

	if confirmed := <-confirms; confirmed.Ack {
		log.Printf("confirmed delivery with delivery tag: %d", confirmed.DeliveryTag)
	} else {
		log.Printf("failed delivery of delivery tag: %d", confirmed.DeliveryTag)
	}
}
```

#### 事务机制ACK

主要解决问题：消费者从队列中获取到消息后，会直接确认签收，假设消费者宕机或者程序出现异常，数据没有正常消费，这种情况就会出现数据丢失。

思路：设置消费者ack为手动，同时将失败的数据记录到库或者日志，通过定时任务或者人为的方式解决此问题。切记，一定要手动释放掉。



